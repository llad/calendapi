"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VBooleanArray = exports.VStringArray = exports.VNumberArray = exports.VBoolean = exports.VNumber = exports.VString = exports.VBase = exports.Validator = exports.VArray = exports.VObject = exports.VObjectBase = void 0;
const json_1 = require("../../utils/json");
const rule_1 = require("./rule");
const sanitizer_1 = require("./sanitizer");
class VObjectBase {
    constructor(container, key) {
        this.keys = [];
        this._isOptional = false;
        this.getValidators = () => {
            const validators = [];
            const thisKeys = [];
            Object.assign(thisKeys, this.keys);
            const walk = (container, keys, isOptional) => {
                for (const v of Object.values(container)) {
                    if (v instanceof VArray || v instanceof VObject) {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        isOptional || (isOptional = v._isOptional);
                        keys.push(...v.keys);
                        walk(v.container, keys, isOptional);
                        const tmp = [];
                        Object.assign(tmp, thisKeys);
                        keys = tmp;
                    }
                    else if (v instanceof VBase) {
                        if (isOptional)
                            v.isOptional();
                        v.baseKeys.push(...keys);
                        validators.push(v);
                    }
                }
            };
            walk(this.container, this.keys, this._isOptional);
            return validators;
        };
        this.container = container;
        if (this instanceof VArray) {
            this.keys.push(key, '[*]');
        }
        else if (this instanceof VObject) {
            this.keys.push(key);
        }
    }
    isOptional() {
        this._isOptional = true;
        return this;
    }
}
exports.VObjectBase = VObjectBase;
class VObject extends VObjectBase {
    constructor(container, key) {
        super(container, key);
    }
}
exports.VObject = VObject;
class VArray extends VObjectBase {
    constructor(container, key) {
        super(container, key);
        this.type = 'array';
    }
}
exports.VArray = VArray;
class Validator {
    constructor() {
        this.isArray = false;
        this.query = (key) => new VString({ target: 'query', key: key });
        this.header = (key) => new VString({ target: 'header', key: key });
        this.body = (key) => new VString({ target: 'body', key: key });
        this.json = (key) => {
            if (this.isArray) {
                return new VStringArray({ target: 'json', key: key });
            }
            else {
                return new VString({ target: 'json', key: key });
            }
        };
        this.array = (path, validator) => {
            this.isArray = true;
            const res = validator(this);
            const arr = new VArray(res, path);
            return arr;
        };
        this.object = (path, validator) => {
            this.isArray = false;
            const res = validator(this);
            const obj = new VObject(res, path);
            return obj;
        };
    }
}
exports.Validator = Validator;
class VBase {
    constructor(options) {
        this.baseKeys = [];
        this._nested = () => (this.baseKeys.length ? true : false);
        this.addSanitizer = (sanitizer) => {
            this.sanitizers.push(sanitizer);
            return this;
        };
        this.message = (text) => {
            const len = this.rules.length;
            if (len >= 1) {
                this.rules[len - 1].customMessage = text;
            }
            return this;
        };
        this.isRequired = () => {
            return this.addRule('isRequired', (value) => {
                if (value !== undefined && value !== null && value !== '')
                    return true;
                return false;
            });
        };
        this.isOptional = () => {
            this._optional = true;
            return this.addRule('isOptional', () => true);
        };
        this.isEqual = (comparison) => {
            return this.addRule('isEqual', (value) => {
                return value === comparison;
            });
        };
        this.asNumber = () => {
            const newVNumber = new VNumber({ ...this, type: 'number' });
            if (this.isArray)
                return newVNumber.asArray();
            return newVNumber;
        };
        this.asBoolean = () => {
            const newVBoolean = new VBoolean({ ...this, type: 'boolean' });
            if (this.isArray)
                return newVBoolean.asArray();
            return newVBoolean;
        };
        this.validate = async (req) => {
            let value = undefined;
            let jsonData = undefined;
            if (this.target === 'query') {
                value = req.query(this.key);
            }
            if (this.target === 'header') {
                value = req.header(this.key);
            }
            if (this.target === 'body') {
                const body = await req.parseBody();
                value = body[this.key];
            }
            if (this.target === 'json') {
                if (this._nested()) {
                    this.key = `${this.baseKeys.join('.')}.${this.key}`;
                }
                let obj = {};
                try {
                    obj = (await req.json());
                }
                catch (e) {
                    throw new Error('Malformed JSON in request body');
                }
                const dst = {};
                value = (0, json_1.JSONPathCopy)(obj, dst, this.key);
                if (this._nested())
                    jsonData = dst;
            }
            const results = [];
            let typeRule = this.rules.shift();
            for (const rule of this.rules) {
                if (rule.type === 'type') {
                    typeRule = rule;
                }
                else if (rule.type === 'value') {
                    const result = this.validateRule(rule, value);
                    result.jsonData || (result.jsonData = jsonData);
                    results.push(result);
                }
            }
            if (typeRule) {
                const typeResult = this.validateRule(typeRule, value);
                typeResult.jsonData || (typeResult.jsonData = jsonData);
                results.unshift(typeResult);
            }
            return results;
        };
        this.validateType = (value) => {
            if (this.isArray) {
                if (!Array.isArray(value)) {
                    return false;
                }
                for (const val of value) {
                    if (typeof val === 'undefined' && this._nested()) {
                        value.pop();
                    }
                    for (const val of value) {
                        if (typeof val !== this.type) {
                            // Value is of wrong type here
                            // If it is not optional and not undefined, return false
                            if (!this._optional || typeof val !== 'undefined')
                                return false;
                        }
                    }
                }
            }
            else {
                if (typeof value !== this.type) {
                    if (this._optional && (typeof value === 'undefined' || Array.isArray(value))) {
                        // Do nothing.
                        // If it is optional it's OK to be `undefined` or Array
                    }
                    else {
                        return false;
                    }
                }
            }
            return true;
        };
        this.validateValue = (func, value) => {
            if (Array.isArray(value)) {
                // Sanitize
                for (const sanitizer of this.sanitizers) {
                    value = value.map((innerVal) => sanitizer(innerVal));
                }
                for (const val of value) {
                    if (!func(val)) {
                        return false;
                    }
                }
                return true;
            }
            else {
                // Sanitize
                for (const sanitizer of this.sanitizers) {
                    value = sanitizer(value);
                }
                if (!func(value)) {
                    return false;
                }
                return true;
            }
        };
        this.getMessage = (opts) => {
            let keyText;
            const valueText = Array.isArray(opts.value)
                ? `${opts.value
                    .map((val) => val === undefined ? 'undefined' : typeof val === 'string' ? `"${val}"` : val)
                    .join(', ')}`
                : opts.value;
            switch (this.target) {
                case 'query':
                    keyText = `the query parameter "${this.key}"`;
                    break;
                case 'header':
                    keyText = `the request header "${this.key}"`;
                    break;
                case 'body':
                    keyText = `the request body "${this.key}"`;
                    break;
                case 'json':
                    keyText = `the JSON body "${this.key}"`;
                    break;
            }
            return `Invalid Value [${valueText}]: ${keyText} is invalid - ${opts.ruleName}`;
        };
        this.target = options.target;
        this.key = options.key;
        this.type = options.type || 'string';
        this.rules = [
            {
                name: this.getTypeRuleName(),
                type: 'type',
                func: this.validateType,
            },
        ];
        this.sanitizers = [];
        this._optional = false;
        this.isArray = options.isArray || false;
    }
    addRule(arg, func) {
        if (typeof arg === 'string' && func) {
            this.rules.push({ name: arg, func, type: 'value' });
        }
        else if (arg instanceof Function) {
            this.rules.push({ name: arg.name, func: arg, type: 'value' });
        }
        return this;
    }
    get(value) {
        const len = this.rules.length;
        if (len > 0) {
            this.rules[this.rules.length - 1].customMessage = value;
        }
        return this;
    }
    getTypeRuleName() {
        const prefix = 'should be';
        return this.isArray ? `${prefix} "${this.type}[]"` : `${prefix} "${this.type}"`;
    }
    validateRule(rule, value) {
        let isValid = false;
        if (this._nested() && this.target != 'json') {
            isValid = false;
        }
        else if (rule.type === 'value') {
            isValid = this.validateValue(rule.func, value);
        }
        else if (rule.type === 'type') {
            isValid = this.validateType(value);
        }
        const message = isValid
            ? undefined
            : rule.customMessage || this.getMessage({ ruleName: rule.name, value });
        const result = {
            isValid: isValid,
            message: message,
            target: this.target,
            key: this.key,
            value,
            ruleName: rule.name,
            ruleType: rule.type,
        };
        return result;
    }
}
exports.VBase = VBase;
class VString extends VBase {
    constructor(options) {
        super(options);
        this.asArray = () => {
            return new VStringArray(this);
        };
        this.isEmpty = (options = { ignore_whitespace: false }) => {
            return this.addRule('isEmpty', (value) => rule_1.rule.isEmpty(value, options));
        };
        this.isLength = (options, arg2) => {
            return this.addRule('isLength', (value) => rule_1.rule.isLength(value, options, arg2));
        };
        this.isAlpha = () => {
            return this.addRule('isAlpha', (value) => rule_1.rule.isAlpha(value));
        };
        this.isNumeric = () => {
            return this.addRule('isNumeric', (value) => rule_1.rule.isNumeric(value));
        };
        this.contains = (elem, options = {
            ignoreCase: false,
            minOccurrences: 1,
        }) => {
            return this.addRule('contains', (value) => rule_1.rule.contains(value, elem, options));
        };
        this.isIn = (options) => {
            return this.addRule('isIn', (value) => rule_1.rule.isIn(value, options));
        };
        this.match = (regExp) => {
            return this.addRule('match', (value) => rule_1.rule.match(value, regExp));
        };
        this.trim = () => {
            return this.addSanitizer((value) => sanitizer_1.sanitizer.trim(value));
        };
        this.type = 'string';
    }
}
exports.VString = VString;
class VNumber extends VBase {
    constructor(options) {
        super(options);
        this.asArray = () => {
            return new VNumberArray(this);
        };
        this.isGte = (min) => {
            return this.addRule('isGte', (value) => rule_1.rule.isGte(value, min));
        };
        this.isLte = (min) => {
            return this.addRule('isLte', (value) => rule_1.rule.isLte(value, min));
        };
        this.type = 'number';
    }
}
exports.VNumber = VNumber;
class VBoolean extends VBase {
    constructor(options) {
        super(options);
        this.asArray = () => {
            return new VBooleanArray(this);
        };
        this.isTrue = () => {
            return this.addRule('isTrue', (value) => rule_1.rule.isTrue(value));
        };
        this.isFalse = () => {
            return this.addRule('isFalse', (value) => rule_1.rule.isFalse(value));
        };
        this.type = 'boolean';
    }
}
exports.VBoolean = VBoolean;
class VNumberArray extends VNumber {
    constructor(options) {
        super(options);
        this.isArray = true;
        this.rules[0].name = this.getTypeRuleName();
    }
}
exports.VNumberArray = VNumberArray;
class VStringArray extends VString {
    constructor(options) {
        super(options);
        this.isArray = true;
        this.rules[0].name = this.getTypeRuleName();
    }
}
exports.VStringArray = VStringArray;
class VBooleanArray extends VBoolean {
    constructor(options) {
        super(options);
        this.isArray = true;
        this.rules[0].name = this.getTypeRuleName();
    }
}
exports.VBooleanArray = VBooleanArray;
