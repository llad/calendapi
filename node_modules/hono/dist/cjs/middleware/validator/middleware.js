"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatorMiddleware = void 0;
const http_status_1 = require("../../utils/http-status");
const object_1 = require("../../utils/object");
const validator_1 = require("./validator");
const validatorMiddleware = (validationFunction, options) => {
    const v = new validator_1.Validator();
    const handler = async (c, next) => {
        const resultSet = {
            hasError: false,
            messages: [],
            results: [],
        };
        const schema = validationFunction(v, c);
        const validatorList = getValidatorList(schema);
        let data = {};
        for (const [keys, validator] of validatorList) {
            let results;
            try {
                results = await validator.validate(c.req);
            }
            catch (e) {
                // Invalid JSON request
                return c.text((0, http_status_1.getStatusText)(400), 400);
            }
            let isValid = true;
            const value = results[0].value;
            const jsonData = results[0].jsonData;
            for (const result of results) {
                if (!result.isValid) {
                    isValid = false;
                    resultSet.hasError = true;
                    if (result.ruleType === 'value' && result.message !== undefined) {
                        resultSet.messages.push(result.message);
                    }
                }
                resultSet.results.push(result);
            }
            // If it's invalid but it has no "value" messages, have to set the "type" messages.
            // This approach is verbose, but if do not so, the response body will be empty.
            if (!isValid && resultSet.messages.length === 0) {
                resultSet.results.map((r) => {
                    if (!r.isValid && r.ruleType === 'type' && r.message) {
                        resultSet.messages.push(r.message);
                    }
                });
            }
            // Set data on request object
            if (isValid) {
                // Set data on request object
                if (jsonData) {
                    const dst = data;
                    data = (0, object_1.mergeObjects)(dst, jsonData);
                }
                else {
                    c.req.valid(keys, value);
                }
            }
        }
        if (!resultSet.hasError) {
            Object.keys(data).map((key) => {
                c.req.valid(key, data[key]);
            });
        }
        if (options && options.done) {
            const res = options.done(resultSet, c);
            if (res) {
                return res;
            }
        }
        if (resultSet.hasError) {
            return c.text(resultSet.messages.join('\n'), 400);
        }
        await next();
    };
    return handler;
};
exports.validatorMiddleware = validatorMiddleware;
function getValidatorList(schema) {
    const map = [];
    for (const [key, value] of Object.entries(schema)) {
        if (value instanceof validator_1.VObjectBase) {
            const validators = value.getValidators();
            for (const validator of validators) {
                map.push([value.keys, validator]);
            }
        }
        else if (value instanceof validator_1.VBase) {
            map.push([[key], value]);
        }
        else {
            const children = getValidatorList(value);
            for (const [keys, validator] of children) {
                map.push([[key, ...keys], validator]);
            }
        }
    }
    return map;
}
